using System.Runtime.InteropServices;

namespace TreeSitter.CSharp;

/// <summary>
/// A TSLanguage is an opaque object that defines how to parse a particular
/// programming language. The code for each TSLanguage is generated by Tree-sitter.
/// Many languages are already available in separate git repositories within the
/// Tree-sitter GitHub organization.
/// </summary>
public sealed partial class TSLanguage : IDisposable {
    internal IntPtr Ptr { get; private set; }

    public string?[] Symbols { get; set; }
    public string?[] Fields { get; set; }
    public Dictionary<string, ushort> FieldIds { get; set; }

    public TSLanguage(IntPtr ptr) {
        Ptr = ptr;

        Symbols = new string?[SymbolCount() + 1];
        for (ushort i = 0; i < Symbols.Length; i++) {
            Symbols[i] = Marshal.PtrToStringAnsi(ts_language_symbol_name(Ptr, i));
        }

        Fields = new string[FieldCount() + 1];
        FieldIds = new Dictionary<string, ushort>((int)FieldCount() + 1);

        for (ushort i = 0; i < Fields.Length; i++) {
            Fields[i] = Marshal.PtrToStringAnsi(ts_language_field_name_for_id(Ptr, i));
            if (Fields[i] is not null) {
                FieldIds.Add(Fields[i]!, i); // TODO: check for dupes, and throw if found
            }
        }

#if false
            for (int i = 0; i < symbols.Length; i++) {
                for (int j = 0; j < i; j++) {
                    Debug.Assert(symbols[i] != symbols[j]);
                }
            }

            for (int i = 0; i < fields.Length; i++) {
                for (int j = 0; j < i; j++) {
                    Debug.Assert(fields[i] != fields[j]);
                }
            }
#endif
    }

    public void Dispose() {
        if (Ptr != IntPtr.Zero) {
            //ts_query_cursor_delete(Ptr);
            Ptr = IntPtr.Zero;
        }
    }

    public TSQuery? NewQuery(string source, out uint errorOffset, out TSQueryError errorType) {
        nint ptr = ts_query_new(Ptr, source, (uint)source.Length, out errorOffset, out errorType);
        return ptr != IntPtr.Zero ? new TSQuery(ptr) : null;
    }


    public uint SymbolCount() {
        return ts_language_symbol_count(Ptr);
    }

    public string SymbolName(ushort symbol) {
        return (symbol != ushort.MaxValue) ? Symbols[symbol]! : "ERROR";
    }

    public ushort SymbolForName(string str, bool isNamed) {
        return ts_language_symbol_for_name(Ptr, str, (uint)str.Length, isNamed);
    }

    public uint FieldCount() {
        return ts_language_field_count(Ptr);
    }

    public string FieldNameForId(ushort fieldId) {
        return Fields[fieldId]!;
    }
    public ushort FieldIdForName(string str) {
        return ts_language_field_id_for_name(Ptr, str, (uint)str.Length);
    }

    public TSSymbolType SymbolType(ushort symbol) {
        return ts_language_symbol_type(Ptr, symbol);
    }

    #region PInvoke
    /**
    * Create a new query from a string containing one or more S-expression
    * patterns. The query is associated with a particular language, and can
    * only be run on syntax nodes parsed with that language.
    *
    * If all of the given patterns are valid, this returns a `TSQuery`.
    * If a pattern is invalid, this returns `NULL`, and provides two pieces
    * of information about the problem:
    * 1. The byte offset of the error is written to the `error_offset` parameter.
    * 2. The type of error is written to the `error_type` parameter.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial IntPtr ts_query_new(IntPtr language, [MarshalAs(UnmanagedType.LPUTF8Str)] string source, uint source_len, out uint error_offset, out TSQueryError error_type);

    /**
    * Get the number of distinct node types in the language.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial uint ts_language_symbol_count(IntPtr language);

    /**
    * Get a node type string for the given numerical id.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial IntPtr ts_language_symbol_name(IntPtr language, ushort symbol);

    /**
    * Get the numerical id for the given node type string.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial ushort ts_language_symbol_for_name(IntPtr language, [MarshalAs(UnmanagedType.LPUTF8Str)] string str, uint length, [MarshalAs(UnmanagedType.Bool)] bool is_named);

    /**
    * Get the number of distinct field names in the language.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial uint ts_language_field_count(IntPtr language);

    /**
    * Get the field name string for the given numerical id.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial IntPtr ts_language_field_name_for_id(IntPtr language, ushort fieldId);

    /**
    * Get the numerical id for the given field name string.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial ushort ts_language_field_id_for_name(IntPtr language, [MarshalAs(UnmanagedType.LPUTF8Str)] string str, uint length);

    /**
    * Check whether the given node type id belongs to named nodes, anonymous nodes,
    * or a hidden nodes.
    *
    * See also `ts_node_is_named`. Hidden nodes are never returned from the API.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial TSSymbolType ts_language_symbol_type(IntPtr language, ushort symbol);

    /**
    * Get the ABI version number for this language. This version number is used
    * to ensure that languages were generated by a compatible version of
    * Tree-sitter.
    *
    * See also `ts_parser_set_language`.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial uint ts_language_version(IntPtr language);
    #endregion
}