using System.Runtime.InteropServices;

namespace TreeSitter.CSharp;

/// <summary>
/// A TSLanguage is an opaque object that defines how to parse a particular
/// programming language. The code for each TSLanguage is generated by Tree-sitter.
/// Many languages are already available in separate git repositories within the
/// Tree-sitter GitHub organization.
/// </summary>
public sealed partial class TSLanguage : IDisposable {
    /// <summary>
    /// A pointer the TreeSitter language instance.
    /// </summary>
    internal IntPtr LanguagePointer { get; private set; }

    /// <summary>
    /// A list of strings that represent the symbols of the language.
    /// That items such as keywords, operators etc.
    /// </summary>
    public List<string> Symbols { get; set; }

    /// <summary>
    /// A list of strings that represent the Fields of the language.
    /// </summary>
    public List<string> Fields { get; set; }

    /// <summary>
    /// A dictionaty that maps strings to numeric ids
    /// </summary>
    public Dictionary<string, ushort> FieldIds { get; set; }

    public TSLanguage(IntPtr languagePtr) {
        if (languagePtr == IntPtr.Zero) {
            throw new InvalidOperationException("Cannot initialize with a Zero Pointer");
        }
        LanguagePointer = languagePtr;

        uint nuSymbols = ts_language_symbol_count(LanguagePointer) + 1;
        //Symbols = new List<string>(new string[nuSymbols]);
        Symbols = new List<string>();
        for (ushort i = 0; i < nuSymbols; i++) {
            string? s = Marshal.PtrToStringAnsi(ts_language_symbol_name(LanguagePointer, i));
            if (s is not null) {
                Symbols.Add(s);
            }
        }

        uint nuFields = FieldCount() + 1;

        // Fields = new List<string>(new string[nuFields]);
        // FieldIds = new Dictionary<string, ushort>((int)nuFields);
        Fields = new List<string>();
        FieldIds = new Dictionary<string, ushort>();

        for (ushort i = 0; i < nuFields; i++) {
            string? s = Marshal.PtrToStringAnsi(ts_language_field_name_for_id(LanguagePointer, i));
            if (s is not null and not "") {
                Fields.Add(s);
                FieldIds.Add(s, i);
            }
        }

#if false
            for (int i = 1; i < symbols.Length; i++) {
                for (int j = 0; j < i; j++) {
                    Debug.Assert(symbols[i] != symbols[j]);
                }
            }

            for (int i = 0; i < fields.Length; i++) {
                for (int j = 0; j < i; j++) {
                    Debug.Assert(fields[i] != fields[j]);
                }
            }

        Console.WriteLine("Symbols");
        foreach (string s in Symbols) {
            Console.Write('"');
            Console.Write(s);
            Console.Write('"');
            Console.Write("\n");
        }

        Console.WriteLine("\n\nFields");
        foreach (string s in Fields) {
            Console.Write('"');
            Console.Write(s);
            Console.Write('"');
            Console.Write("\n");
        }
        foreach (KeyValuePair<string, ushort> s in FieldIds) {
            Console.Write('"');
            Console.Write(s.Key);
            Console.Write('"');
            Console.Write(" --> ");
            Console.Write('"');
            Console.Write(s.Value);
            Console.Write('"');
            Console.Write("\n");
        }
#endif
    }

    public void Dispose() {
        if (LanguagePointer != IntPtr.Zero) {
            //ts_query_cursor_delete(LanguagePointer);
            LanguagePointer = IntPtr.Zero;
        }
    }

    public TSQuery? NewQuery(string source, out uint errorOffset, out TSQueryError errorType) {
        nint ptr = ts_query_new(LanguagePointer, source, (uint)source.Length, out errorOffset, out errorType);
        return ptr != IntPtr.Zero ? new TSQuery(ptr) : null;
    }


    public string SymbolName(ushort symbol) {
        //TODO: Overload the index operator [] for this
        if (symbol < Symbols.Count) {
            return Symbols[symbol];
        } else {
            return "ERROR";
        }
    }

    public ushort SymbolForName(string str, bool isNamed) {
        return ts_language_symbol_for_name(LanguagePointer, str, (uint)str.Length, isNamed);
    }

    public uint FieldCount() {
        return ts_language_field_count(LanguagePointer);
    }

    public string FieldNameForId(ushort fieldId) {
        return Fields[fieldId]!;
    }
    public ushort FieldIdForName(string str) {
        return ts_language_field_id_for_name(LanguagePointer, str, (uint)str.Length);
    }

    public TSSymbolType SymbolType(ushort symbol) {
        return ts_language_symbol_type(LanguagePointer, symbol);
    }

    #region PInvoke
    /**
    * Create a new query from a string containing one or more S-expression
    * patterns. The query is associated with a particular language, and can
    * only be run on syntax nodes parsed with that language.
    *
    * If all of the given patterns are valid, this returns a `TSQuery`.
    * If a pattern is invalid, this returns `NULL`, and provides two pieces
    * of information about the problem:
    * 1. The byte offset of the error is written to the `error_offset` parameter.
    * 2. The type of error is written to the `error_type` parameter.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial IntPtr ts_query_new(IntPtr language, [MarshalAs(UnmanagedType.LPUTF8Str)] string source, uint source_len, out uint error_offset, out TSQueryError error_type);

    /**
    * Get the number of distinct node types in the language.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial uint ts_language_symbol_count(IntPtr language);

    /**
    * Get a node type string for the given numerical id.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial IntPtr ts_language_symbol_name(IntPtr language, ushort symbol);

    /**
    * Get the numerical id for the given node type string.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial ushort ts_language_symbol_for_name(IntPtr language, [MarshalAs(UnmanagedType.LPUTF8Str)] string str, uint length, [MarshalAs(UnmanagedType.Bool)] bool is_named);

    /**
    * Get the number of distinct field names in the language.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial uint ts_language_field_count(IntPtr language);

    /**
    * Get the field name string for the given numerical id.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial IntPtr ts_language_field_name_for_id(IntPtr language, ushort fieldId);

    /**
    * Get the numerical id for the given field name string.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial ushort ts_language_field_id_for_name(IntPtr language, [MarshalAs(UnmanagedType.LPUTF8Str)] string str, uint length);

    /**
    * Check whether the given node type id belongs to named nodes, anonymous nodes,
    * or a hidden nodes.
    *
    * See also `ts_node_is_named`. Hidden nodes are never returned from the API.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial TSSymbolType ts_language_symbol_type(IntPtr language, ushort symbol);

    /**
    * Get the ABI version number for this language. This version number is used
    * to ensure that languages were generated by a compatible version of
    * Tree-sitter.
    *
    * See also `ts_parser_set_language`.
    */
    [LibraryImport("tree-sitter.dll")]
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
    private static partial uint ts_language_version(IntPtr language);
    #endregion
}